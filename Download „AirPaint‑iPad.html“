<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>AirPaint – iPad</title>
<style>
  :root{
    --bg: #0b0c0f;
    --panel: rgba(255,255,255,0.08);
    --panel-strong: rgba(255,255,255,0.12);
    --border: rgba(255,255,255,0.18);
    --text: rgba(255,255,255,0.92);
    --muted: rgba(255,255,255,0.65);
    --accent: #0a84ff;
    --danger: #ff3b30;
    --success: #34c759;
  }
  html,body{
    height:100%;
    margin:0;
    background: radial-gradient(1200px 1200px at 80% -10%, #172033 0%, #0e1117 40%, #0a0b0d 100%) fixed;
    color:var(--text);
    -webkit-font-smoothing: antialiased;
    font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Arial, Helvetica, sans-serif;
  }
  .app{
    display:flex;
    flex-direction:column;
    height:100%;
  }
  header{
    display:flex;
    align-items:center;
    gap:.75rem;
    padding: env(safe-area-inset-top) 1rem .75rem;
    padding-top: calc(env(safe-area-inset-top) + .5rem);
    position: sticky;
    top:0;
    z-index:10;
    backdrop-filter: saturate(160%) blur(16px);
    -webkit-backdrop-filter: saturate(160%) blur(16px);
    background: linear-gradient(180deg, rgba(10,10,12,0.65), rgba(10,10,12,0.25));
    border-bottom: 1px solid var(--border);
  }
  h1{
    font-weight: 700;
    font-size: 1.15rem;
    letter-spacing: .01em;
    margin: 0 .25rem 0 0;
  }
  .spacer{ flex:1 }
  .toolbar{
    display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;
  }
  .chip, .btn{
    appearance:none; border:1px solid var(--border);
    background: var(--panel);
    padding:.5rem .75rem; border-radius: 12px; color:var(--text);
    font-size:.95rem; font-weight:600;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    cursor:pointer; user-select:none; -webkit-user-select:none;
    transition: transform .12s ease, background .12s ease, border-color .12s ease;
  }
  .btn:active{ transform: scale(.98) }
  .btn.primary{ border-color: rgba(10,132,255,.35); background: linear-gradient(180deg, rgba(10,132,255,.22), rgba(10,132,255,.14)); }
  .btn.danger{ border-color: rgba(255,59,48,.4); background: linear-gradient(180deg, rgba(255,59,48,.22), rgba(255,59,48,.12)); }
  .btn.success{ border-color: rgba(52,199,89,.4); background: linear-gradient(180deg, rgba(52,199,89,.22), rgba(52,199,89,.12)); }
  .segmented{
    display:inline-flex; border:1px solid var(--border); border-radius:12px; overflow:hidden; background:var(--panel);
  }
  .segmented button{
    border:0; background:transparent; padding:.5rem .75rem; color:var(--muted); font-weight:600;
  }
  .segmented button.active{ color:var(--text); background:var(--panel-strong) }
  .panel{
    margin: .75rem auto 0;
    background: var(--panel);
    border:1px solid var(--border);
    border-radius: 16px;
    padding: .65rem .8rem;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    display:flex; align-items:center; gap:.8rem; flex-wrap:wrap;
  }
  label { font-size:.9rem; color:var(--muted); }
  input[type="range"]{ width: 120px }
  input[type="color"]{
    width: 36px; height: 28px; border-radius: 8px; border:1px solid var(--border); background: transparent; padding:0;
  }
  main{
    position:relative; flex:1; overflow:hidden;
  }
  #stage{
    width:100%; height:100%;
    position:absolute; inset:0;
    touch-action: none;
  }
  #paint, #overlay{
    position:absolute; inset:0; width:100%; height:100%;
  }
  #video{
    position:absolute; right: 1rem; bottom: 1rem; width: 200px; height: 150px;
    border-radius: 12px; overflow:hidden; border:1px solid var(--border);
    transform: scaleX(-1); /* mirror for selfie view */
    box-shadow: 0 10px 24px rgba(0,0,0,.35);
  }
  #video video{
    width:100%; height:100%; object-fit:cover;
    filter: saturate(110%);
  }
  .hint{
    position:absolute; left:50%; transform: translateX(-50%);
    bottom: calc(env(safe-area-inset-bottom) + .75rem);
    padding: .5rem .9rem; border-radius: 12px;
    background: var(--panel);
    border:1px solid var(--border);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    color: var(--muted);
    font-weight:600;
    box-shadow: 0 10px 24px rgba(0,0,0,.35);
  }
  .dot{
    position:absolute; width: 10px; height:10px; border-radius:50%;
    background: var(--accent); box-shadow: 0 0 0 4px rgba(10,132,255,.25);
    transform: translate(-50%, -50%);
    pointer-events:none;
  }
  footer{
    height: env(safe-area-inset-bottom);
  }
</style>

<!-- MediaPipe Hands & utilities -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
</head>
<body>
<div class="app">
  <header>
    <h1>AirPaint</h1>
    <div class="segmented" role="tablist" aria-label="Brush Mode">
      <button id="mode-draw" class="active" aria-selected="true">Zeichnen</button>
      <button id="mode-erase" aria-selected="false">Radieren</button>
    </div>
    <div class="spacer"></div>
    <div class="toolbar">
      <button id="btn-undo" class="btn">Rückgängig</button>
      <button id="btn-clear" class="btn danger">Leeren</button>
      <button id="btn-snap" class="btn primary">Snapshot</button>
    </div>
  </header>

  <div class="panel">
    <label for="color">Farbe</label>
    <input id="color" type="color" value="#0a84ff" />
    <label for="size">Pinsel</label>
    <input id="size" type="range" min="2" max="40" step="1" value="8" />
    <label><input id="show-skeleton" type="checkbox" checked /> Hand-Overlay</label>
    <span id="status" aria-live="polite">Kamera wird initialisiert…</span>
  </div>

  <main id="stage">
    <canvas id="paint"></canvas>
    <canvas id="overlay"></canvas>
    <div id="video"><video id="input" playsinline></video></div>
    <div id="cursor" class="dot" hidden></div>
    <div class="hint">Pinch (Daumen + Zeigefinger) = zeichnen · ✌️ (Zeige + Mittelfinger) = pausieren</div>
  </main>
  <footer></footer>
</div>

<script>
(function(){
  // DOM
  const videoEl = document.getElementById('input');
  const paint = document.getElementById('paint');
  const overlay = document.getElementById('overlay');
  const cursor = document.getElementById('cursor');
  const statusEl = document.getElementById('status');
  const showSkeletonEl = document.getElementById('show-skeleton');
  const sizeEl = document.getElementById('size');
  const colorEl = document.getElementById('color');
  const btnUndo = document.getElementById('btn-undo');
  const btnClear = document.getElementById('btn-clear');
  const btnSnap = document.getElementById('btn-snap');
  const modeDraw = document.getElementById('mode-draw');
  const modeErase = document.getElementById('mode-erase');

  let drawMode = 'draw'; // 'draw' | 'erase'
  modeDraw.addEventListener('click', () => { drawMode='draw'; modeDraw.classList.add('active'); modeErase.classList.remove('active'); });
  modeErase.addEventListener('click', () => { drawMode='erase'; modeErase.classList.add('active'); modeDraw.classList.remove('active'); });

  // Canvas setup
  const paintCtx = paint.getContext('2d');
  const overlayCtx = overlay.getContext('2d');
  function resize(){
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const {width, height} = document.getElementById('stage').getBoundingClientRect();
    [paint, overlay].forEach(c => {
      c.width = Math.floor(width * dpr);
      c.height = Math.floor(height * dpr);
      c.style.width = width + 'px';
      c.style.height = height + 'px';
    });
    paintCtx.setTransform(dpr,0,0,dpr,0,0);
    overlayCtx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // History for undo
  const history = [];
  function snapshot(){
    history.push(paint.toDataURL('image/png'));
    if(history.length > 25) history.shift();
  }
  btnUndo.addEventListener('click', () => {
    const last = history.pop();
    if(!last) return;
    const img = new Image();
    img.onload = () => {
      paintCtx.clearRect(0,0,paint.width,paint.height);
      paintCtx.drawImage(img,0,0,paint.width,paint.height);
    };
    img.src = last;
  });
  btnClear.addEventListener('click', () => {
    snapshot();
    paintCtx.clearRect(0,0,paint.width,paint.height);
  });
  btnSnap.addEventListener('click', () => {
    const a = document.createElement('a');
    a.download = 'airpaint.png';
    a.href = paint.toDataURL('image/png');
    a.click();
  });

  // Drawing state
  let lastPoint = null;
  let isPinching = false;
  let pausedByPeace = false;

  function lineTo(x,y){
    const s = parseFloat(sizeEl.value);
    paintCtx.lineWidth = s;
    paintCtx.lineCap = 'round';
    paintCtx.lineJoin = 'round';
    paintCtx.strokeStyle = drawMode==='erase' ? 'rgba(0,0,0,1)' : colorEl.value;
    if(drawMode==='erase'){
      paintCtx.globalCompositeOperation = 'destination-out';
    }else{
      paintCtx.globalCompositeOperation = 'source-over';
    }
    if(lastPoint==null){ paintCtx.beginPath(); paintCtx.moveTo(x,y); }
    paintCtx.lineTo(x,y);
    paintCtx.stroke();
  }

  // Utility: distance between landmarks
  function dist(a,b){
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.hypot(dx,dy);
  }

  // MediaPipe Hands
  const hands = new Hands.Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    selfieMode: true,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
  });

  hands.onResults(onResults);

  // Camera
  async function startCamera(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: {ideal: 1280}, height: {ideal: 720} },
        audio: false
      });
      videoEl.srcObject = stream;
      await videoEl.play();
      statusEl.textContent = 'Bereit. Pinch zum Zeichnen.';
      const camera = new CameraUtils.Camera(videoEl, {
        onFrame: async () => {
          await hands.send({image: videoEl});
        },
        width: 1280, height: 720
      });
      camera.start();
    }catch(err){
      console.error(err);
      statusEl.textContent = 'Kamera-Zugriff fehlgeschlagen. Öffne die Datei über HTTPS (nicht file://) und erlaube Kamerazugriff.';
    }
  }

  startCamera();

  // Convert normalized landmarks to canvas coords (mirrored)
  function toCanvas(p){
    const rect = overlay.getBoundingClientRect();
    return {
      x: (1 - p.x) * rect.width,
      y: p.y * rect.height
    };
  }

  // Peace sign detection: index+middle extended, thumb not pinched
  function isPeace(landmarks){
    // Simple heuristic: tips (8,12) far from corresponding PIP (6,10), while pinch not active
    const extendedIndex = dist(landmarks[8], landmarks[6]) > 0.06;
    const extendedMiddle = dist(landmarks[12], landmarks[10]) > 0.06;
    const together = dist(landmarks[8], landmarks[12]) > 0.03; // separate enough
    return extendedIndex && extendedMiddle && together;
  }

  function onResults(results){
    overlayCtx.clearRect(0,0,overlay.width,overlay.height);

    if(results.multiHandLandmarks && results.multiHandLandmarks.length){
      const lm = results.multiHandLandmarks[0];

      // Scale reference for pinch threshold ~ hand size
      const scale = dist(lm[5], lm[17]); // index MCP to pinky MCP
      const pinch = dist(lm[4], lm[8]) < Math.max(0.03, scale * 0.33);
      const peace = isPeace(lm);

      if(peace){
        pausedByPeace = true;
        isPinching = false;
        lastPoint = null;
      }else{
        pausedByPeace = false;
      }

      const tip = lm[8];
      const pt = toCanvas(tip);
      cursor.hidden = false;
      cursor.style.left = pt.x + 'px';
      cursor.style.top = pt.y + 'px';

      if(!pausedByPeace && pinch){
        if(!isPinching){ snapshot(); } // begin stroke
        isPinching = true;
        lineTo(pt.x, pt.y);
        lastPoint = pt;
      }else{
        isPinching = false;
        lastPoint = null;
      }

      if(showSkeletonEl.checked){
        overlayCtx.save();
        overlayCtx.scale(-1,1);
        overlayCtx.translate(-overlay.width,0);
        DrawingUtils.drawConnectors(overlayCtx, lm, Hands.HAND_CONNECTIONS, {color: '#ffffff55', lineWidth: 2});
        DrawingUtils.drawLandmarks(overlayCtx, lm, {color: '#ffffffaa', lineWidth: 1, radius: 2});
        overlayCtx.restore();
      }
    }else{
      cursor.hidden = true;
      lastPoint = null;
      isPinching = false;
    }
  }

  // Prevent iOS auto-sleep while painting (best-effort)
  let wakeLock = null;
  async function requestWakeLock(){
    try{
      if('wakeLock' in navigator){
        wakeLock = await navigator.wakeLock.request('screen');
      }
    }catch(e){ /* ignore */ }
  }
  requestWakeLock();

  // Touch gestures: allow finger painting directly on screen as fallback
  let touching = false;
  overlay.addEventListener('touchstart', (e)=>{
    touching = true;
    const t = e.touches[0];
    const rect = overlay.getBoundingClientRect();
    snapshot();
    lineTo(t.clientX - rect.left, t.clientY - rect.top);
  }, {passive:true});
  overlay.addEventListener('touchmove', (e)=>{
    if(!touching) return;
    const t = e.touches[0];
    const rect = overlay.getBoundingClientRect();
    lineTo(t.clientX - rect.left, t.clientY - rect.top);
  }, {passive:true});
  overlay.addEventListener('touchend', ()=>{ touching=false; lastPoint=null; }, {passive:true});

})();</script>
</body>
</html>
